// Vulnerability Management System for IoT Security
// Assignment 3: Vulnerability Management Implementation

import axios from 'axios';
import * as crypto from 'crypto';
import * as fs from 'fs/promises';
import * as path from 'path';
import { EventEmitter } from 'events';

export interface CVEData {
  id: string;
  description: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cvssScore: number;
  publishedDate: Date;
  modifiedDate: Date;
  affectedProducts: string[];
  references: string[];
  cweId?: string;
}

export interface VulnerabilityReport {
  scanId: string;
  deviceId: string;
  timestamp: Date;
  vulnerabilities: DeviceVulnerability[];
  scanType: 'AUTOMATED' | 'MANUAL' | 'SCHEDULED';
  scanDuration: number; // in milliseconds
  riskScore: number;
}

export interface DeviceVulnerability {
  id: string;
  cveId: string;
  title: string;
  description: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cvssScore: number;
  detectedAt: Date;
  component: string;
  version: string;
  fixAvailable: boolean;
  fixVersion?: string;
  patchUrl?: string;
  exploitAvailable: boolean;
  riskLevel: number;
}

export interface PatchManagement {
  patchId: string;
  vulnerabilityId: string;
  deviceId: string;
  patchVersion: string;
  releaseDate: Date;
  installationDate?: Date;
  status: 'AVAILABLE' | 'DOWNLOADING' | 'INSTALLED' | 'FAILED' | 'PENDING_REBOOT';
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  size: number; // in bytes
  checksum: string;
  rollbackSupported: boolean;
}

export class VulnerabilityManager extends EventEmitter {
  private vulnerabilityDatabase = new Map<string, CVEData>();
  private deviceVulnerabilities = new Map<string, VulnerabilityReport[]>();
  private patchManagement = new Map<string, PatchManagement[]>();
  private scanSchedule = new Map<string, NodeJS.Timeout>();
  private readonly dbPath: string;
  private readonly cveApiUrl = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

  constructor(databasePath: string = './vulnerability-db') {
    super();
    this.dbPath = databasePath;
    this.initializeDatabase();
  }

  /**
   * Initialize vulnerability database
   */
  private async initializeDatabase(): Promise<void> {
    try {
      await fs.mkdir(this.dbPath, { recursive: true });
      await this.loadVulnerabilityDatabase();
    } catch (error) {
      console.error('Failed to initialize vulnerability database:', error);
    }
  }

  /**
   * Automated vulnerability scanning for IoT devices
   */
  async scanDevice(
    deviceId: string,
    deviceInfo: DeviceInfo,
    scanType: 'AUTOMATED' | 'MANUAL' | 'SCHEDULED' = 'MANUAL'
  ): Promise<VulnerabilityReport> {
    const scanId = crypto.randomUUID();
    const startTime = Date.now();
    
    console.log(`Starting vulnerability scan for device: ${deviceId}`);
    
    try {
      const vulnerabilities: DeviceVulnerability[] = [];

      // Scan for known CVEs in device components
      for (const component of deviceInfo.components) {
        const componentVulns = await this.scanComponent(component);
        vulnerabilities.push(...componentVulns);
      }

      // Scan for configuration vulnerabilities
      const configVulns = await this.scanConfiguration(deviceInfo);
      vulnerabilities.push(...configVulns);

      // Scan for network vulnerabilities
      const networkVulns = await this.scanNetworkConfiguration(deviceInfo);
      vulnerabilities.push(...networkVulns);

      // Calculate risk score
      const riskScore = this.calculateRiskScore(vulnerabilities);

      const report: VulnerabilityReport = {
        scanId,
        deviceId,
        timestamp: new Date(),
        vulnerabilities,
        scanType,
        scanDuration: Date.now() - startTime,
        riskScore
      };

      // Store report
      const deviceReports = this.deviceVulnerabilities.get(deviceId) || [];
      deviceReports.push(report);
      this.deviceVulnerabilities.set(deviceId, deviceReports);

      // Emit scan completion event
      this.emit('scanCompleted', report);

      // Auto-generate patches for critical vulnerabilities
      await this.generatePatchRecommendations(deviceId, vulnerabilities);

      console.log(`Vulnerability scan completed for ${deviceId}. Found ${vulnerabilities.length} vulnerabilities.`);
      return report;

    } catch (error) {
      console.error(`Vulnerability scan failed for device ${deviceId}:`, error);
      throw error;
    }
  }

  /**
   * Scan individual component for vulnerabilities
   */
  private async scanComponent(component: ComponentInfo): Promise<DeviceVulnerability[]> {
    const vulnerabilities: DeviceVulnerability[] = [];

    try {
      // Search for CVEs affecting this component
      const cveData = await this.searchCVEDatabase(component.name, component.version);
      
      for (const cve of cveData) {
        const vulnerability: DeviceVulnerability = {
          id: crypto.randomUUID(),
          cveId: cve.id,
          title: `${component.name} ${component.version} - ${cve.id}`,
          description: cve.description,
          severity: cve.severity,
          cvssScore: cve.cvssScore,
          detectedAt: new Date(),
          component: component.name,
          version: component.version,
          fixAvailable: await this.checkFixAvailability(cve.id, component),
          exploitAvailable: await this.checkExploitAvailability(cve.id),
          riskLevel: this.calculateComponentRisk(cve, component)
        };

        // Check for fix version
        const fixInfo = await this.getFixInformation(cve.id, component);
        if (fixInfo) {
          vulnerability.fixVersion = fixInfo.version;
          vulnerability.patchUrl = fixInfo.url;
        }

        vulnerabilities.push(vulnerability);
      }

    } catch (error) {
      console.error(`Component scan failed for ${component.name}:`, error);
    }

    return vulnerabilities;
  }

  /**
   * Scan device configuration for security issues
   */
  private async scanConfiguration(deviceInfo: DeviceInfo): Promise<DeviceVulnerability[]> {
    const vulnerabilities: DeviceVulnerability[] = [];

    // Check for weak authentication
    if (deviceInfo.authentication?.type === 'basic' || !deviceInfo.authentication?.mfa) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        cveId: 'CONFIG-WEAK-AUTH',
        title: 'Weak Authentication Configuration',
        description: 'Device uses weak authentication mechanisms',
        severity: 'HIGH',
        cvssScore: 7.5,
        detectedAt: new Date(),
        component: 'Authentication',
        version: deviceInfo.firmwareVersion,
        fixAvailable: true,
        exploitAvailable: true,
        riskLevel: 8
      });
    }

    // Check for unencrypted communication
    if (!deviceInfo.encryption?.dataInTransit) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        cveId: 'CONFIG-NO-ENCRYPTION',
        title: 'Unencrypted Data Transmission',
        description: 'Device transmits data without encryption',
        severity: 'CRITICAL',
        cvssScore: 9.1,
        detectedAt: new Date(),
        component: 'Communication',
        version: deviceInfo.firmwareVersion,
        fixAvailable: true,
        exploitAvailable: true,
        riskLevel: 9
      });
    }

    // Check for default credentials
    if (deviceInfo.hasDefaultCredentials) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        cveId: 'CONFIG-DEFAULT-CREDS',
        title: 'Default Credentials Detected',
        description: 'Device still uses default username/password',
        severity: 'CRITICAL',
        cvssScore: 9.8,
        detectedAt: new Date(),
        component: 'Authentication',
        version: deviceInfo.firmwareVersion,
        fixAvailable: true,
        exploitAvailable: true,
        riskLevel: 10
      });
    }

    return vulnerabilities;
  }

  /**
   * Scan network configuration for vulnerabilities
   */
  private async scanNetworkConfiguration(deviceInfo: DeviceInfo): Promise<DeviceVulnerability[]> {
    const vulnerabilities: DeviceVulnerability[] = [];

    // Check for open ports
    if (deviceInfo.openPorts && deviceInfo.openPorts.length > 0) {
      for (const port of deviceInfo.openPorts) {
        if (this.isUnsafePort(port)) {
          vulnerabilities.push({
            id: crypto.randomUUID(),
            cveId: `NETWORK-OPEN-PORT-${port}`,
            title: `Unnecessary Open Port: ${port}`,
            description: `Port ${port} is open and may expose attack surface`,
            severity: 'MEDIUM',
            cvssScore: 5.3,
            detectedAt: new Date(),
            component: 'Network',
            version: deviceInfo.firmwareVersion,
            fixAvailable: true,
            exploitAvailable: false,
            riskLevel: 5
          });
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Integrate with CVE databases (NVD, MITRE, etc.)
   */
  async updateCVEDatabase(): Promise<void> {
    console.log('Updating CVE database from external sources...');
    
    try {
      // Get recent CVEs from NVD
      const response = await axios.get(`${this.cveApiUrl}`, {
        params: {
          resultsPerPage: 100,
          startIndex: 0
        },
        timeout: 30000
      });

      if (response.data && response.data.vulnerabilities) {
        for (const vuln of response.data.vulnerabilities) {
          const cveData = this.parseCVEData(vuln);
          this.vulnerabilityDatabase.set(cveData.id, cveData);
        }
      }

      // Save updated database
      await this.saveVulnerabilityDatabase();
      
      console.log(`Updated CVE database with ${response.data.vulnerabilities.length} entries`);
      this.emit('databaseUpdated', { count: response.data.vulnerabilities.length });

    } catch (error) {
      console.error('Failed to update CVE database:', error);
      // Fallback to cached database
    }
  }

  /**
   * Generate patch recommendations and management
   */
  async generatePatchRecommendations(
    deviceId: string,
    vulnerabilities: DeviceVulnerability[]
  ): Promise<PatchManagement[]> {
    const patches: PatchManagement[] = [];

    for (const vuln of vulnerabilities) {
      if (vuln.fixAvailable && vuln.severity !== 'LOW') {
        const patch: PatchManagement = {
          patchId: crypto.randomUUID(),
          vulnerabilityId: vuln.id,
          deviceId,
          patchVersion: vuln.fixVersion || 'latest',
          releaseDate: new Date(),
          status: 'AVAILABLE',
          priority: vuln.severity,
          size: Math.floor(Math.random() * 10000000) + 1000000, // Simulated size
          checksum: crypto.randomBytes(32).toString('hex'),
          rollbackSupported: true
        };

        patches.push(patch);
      }
    }

    // Store patch recommendations
    const devicePatches = this.patchManagement.get(deviceId) || [];
    devicePatches.push(...patches);
    this.patchManagement.set(deviceId, devicePatches);

    // Emit patch recommendations
    this.emit('patchesAvailable', { deviceId, patches });

    return patches;
  }

  /**
   * Install patch on device
   */
  async installPatch(deviceId: string, patchId: string): Promise<boolean> {
    const devicePatches = this.patchManagement.get(deviceId) || [];
    const patch = devicePatches.find(p => p.patchId === patchId);

    if (!patch) {
      throw new Error(`Patch ${patchId} not found for device ${deviceId}`);
    }

    try {
      console.log(`Installing patch ${patchId} on device ${deviceId}...`);
      
      // Update patch status
      patch.status = 'DOWNLOADING';
      this.emit('patchStatusUpdate', { deviceId, patchId, status: 'DOWNLOADING' });

      // Simulate download
      await this.simulateDelay(2000);
      
      // Install patch
      patch.status = 'INSTALLED';
      patch.installationDate = new Date();
      this.emit('patchStatusUpdate', { deviceId, patchId, status: 'INSTALLED' });

      console.log(`Patch ${patchId} installed successfully on device ${deviceId}`);
      return true;

    } catch (error) {
      patch.status = 'FAILED';
      this.emit('patchStatusUpdate', { deviceId, patchId, status: 'FAILED' });
      console.error(`Patch installation failed:`, error);
      return false;
    }
  }

  /**
   * Schedule automated vulnerability scans
   */
  scheduleVulnerabilityScan(deviceId: string, intervalHours: number = 24): void {
    // Clear existing schedule
    if (this.scanSchedule.has(deviceId)) {
      clearInterval(this.scanSchedule.get(deviceId)!);
    }

    // Set new schedule
    const interval = setInterval(async () => {
      try {
        // Get device info (in real implementation, fetch from device registry)
        const deviceInfo = await this.getDeviceInfo(deviceId);
        await this.scanDevice(deviceId, deviceInfo, 'SCHEDULED');
      } catch (error) {
        console.error(`Scheduled scan failed for device ${deviceId}:`, error);
      }
    }, intervalHours * 60 * 60 * 1000);

    this.scanSchedule.set(deviceId, interval);
    console.log(`Scheduled vulnerability scan for device ${deviceId} every ${intervalHours} hours`);
  }

  /**
   * Get vulnerability report for device
   */
  getVulnerabilityReport(deviceId: string): VulnerabilityReport[] {
    return this.deviceVulnerabilities.get(deviceId) || [];
  }

  /**
   * Get patch management status for device
   */
  getPatchStatus(deviceId: string): PatchManagement[] {
    return this.patchManagement.get(deviceId) || [];
  }

  /**
   * Helper methods
   */
  private async searchCVEDatabase(componentName: string, version: string): Promise<CVEData[]> {
    const results: CVEData[] = [];
    
    this.vulnerabilityDatabase.forEach((cve, _) => {
      if (cve.affectedProducts.some(product => 
        product.toLowerCase().includes(componentName.toLowerCase())
      )) {
        results.push(cve);
      }
    });
    
    return results;
  }

  private async checkFixAvailability(cveId: string, component: ComponentInfo): Promise<boolean> {
    // Simulate fix availability check
    return Math.random() > 0.3; // 70% chance of fix being available
  }

  private async checkExploitAvailability(cveId: string): Promise<boolean> {
    // Simulate exploit availability check
    return Math.random() > 0.7; // 30% chance of exploit being available
  }

  private calculateRiskScore(vulnerabilities: DeviceVulnerability[]): number {
    if (vulnerabilities.length === 0) return 0;
    
    let totalRisk = 0;
    for (const vuln of vulnerabilities) {
      totalRisk += vuln.riskLevel;
    }
    
    return Math.min(totalRisk / vulnerabilities.length, 10);
  }

  private calculateComponentRisk(cve: CVEData, component: ComponentInfo): number {
    let risk = cve.cvssScore;
    
    // Increase risk for critical components
    if (component.critical) risk += 2;
    
    // Increase risk for internet-facing components
    if (component.internetFacing) risk += 1;
    
    return Math.min(risk, 10);
  }

  private isUnsafePort(port: number): boolean {
    const unsafePorts = [21, 23, 135, 139, 445, 1433, 3389];
    return unsafePorts.includes(port);
  }

  private parseCVEData(nvdVuln: any): CVEData {
    const cve = nvdVuln.cve;
    return {
      id: cve.id,
      description: cve.descriptions[0]?.value || 'No description available',
      severity: this.mapCVSSToSeverity(nvdVuln.impact?.baseMetricV3?.cvssV3?.baseScore || 0),
      cvssScore: nvdVuln.impact?.baseMetricV3?.cvssV3?.baseScore || 0,
      publishedDate: new Date(cve.published),
      modifiedDate: new Date(cve.lastModified),
      affectedProducts: cve.configurations?.nodes?.map((node: any) => 
        node.cpeMatch?.map((match: any) => match.criteria).join(', ')
      ).filter(Boolean) || [],
      references: cve.references?.map((ref: any) => ref.url) || [],
      cweId: cve.weaknesses?.[0]?.description?.[0]?.value
    };
  }

  private mapCVSSToSeverity(score: number): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    if (score >= 9.0) return 'CRITICAL';
    if (score >= 7.0) return 'HIGH';
    if (score >= 4.0) return 'MEDIUM';
    return 'LOW';
  }

  private async getFixInformation(cveId: string, component: ComponentInfo): Promise<{version: string, url: string} | null> {
    // Simulate fix information lookup
    if (Math.random() > 0.5) {
      return {
        version: `${component.version}.1`,
        url: `https://example.com/patches/${cveId}`
      };
    }
    return null;
  }

  private async getDeviceInfo(deviceId: string): Promise<DeviceInfo> {
    // Simulate device info retrieval
    return {
      id: deviceId,
      firmwareVersion: '1.2.3',
      components: [
        { name: 'OpenSSL', version: '1.1.1k', critical: true, internetFacing: true },
        { name: 'Linux Kernel', version: '5.4.0', critical: true, internetFacing: false }
      ],
      authentication: { type: 'basic', mfa: false },
      encryption: { dataInTransit: false, dataAtRest: true },
      hasDefaultCredentials: false,
      openPorts: [22, 80, 443]
    };
  }

  private async saveVulnerabilityDatabase(): Promise<void> {
    try {
      const dbFile = path.join(this.dbPath, 'cve-database.json');
      const data = Array.from(this.vulnerabilityDatabase.entries());
      await fs.writeFile(dbFile, JSON.stringify(data, null, 2));
    } catch (error) {
      console.error('Failed to save vulnerability database:', error);
    }
  }

  private async loadVulnerabilityDatabase(): Promise<void> {
    try {
      const dbFile = path.join(this.dbPath, 'cve-database.json');
      const data = await fs.readFile(dbFile, 'utf8');
      const entries = JSON.parse(data);
      this.vulnerabilityDatabase = new Map(entries);
    } catch (error) {
      // Database doesn't exist yet, start with empty database
      this.vulnerabilityDatabase = new Map();
    }
  }

  private async simulateDelay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Supporting interfaces
export interface ComponentInfo {
  name: string;
  version: string;
  critical: boolean;
  internetFacing: boolean;
}

export interface DeviceInfo {
  id: string;
  firmwareVersion: string;
  components: ComponentInfo[];
  authentication?: {
    type: string;
    mfa: boolean;
  };
  encryption?: {
    dataInTransit: boolean;
    dataAtRest: boolean;
  };
  hasDefaultCredentials: boolean;
  openPorts: number[];
}

// Example usage and testing
export class VulnerabilityTester {
  static async runTests(): Promise<void> {
    console.log('=== Vulnerability Management Tests ===');
    
    const vulnManager = new VulnerabilityManager('./test-vuln-db');
    
    // Set up event listeners
    vulnManager.on('scanCompleted', (report) => {
      console.log(`✓ Scan completed for ${report.deviceId}: ${report.vulnerabilities.length} vulnerabilities found`);
    });
    
    vulnManager.on('patchesAvailable', (data) => {
      console.log(`✓ ${data.patches.length} patches available for device ${data.deviceId}`);
    });

    try {
      // Test 1: Update CVE database (use mock data in test)
      console.log('\n1. Testing CVE database update...');
      await vulnManager.updateCVEDatabase();
      
      // Test 2: Scan device for vulnerabilities
      console.log('\n2. Testing device vulnerability scan...');
      const deviceInfo: DeviceInfo = {
        id: 'test-device-001',
        firmwareVersion: '1.0.0',
        components: [
          { name: 'OpenSSL', version: '1.1.1k', critical: true, internetFacing: true },
          { name: 'nginx', version: '1.18.0', critical: false, internetFacing: true }
        ],
        authentication: { type: 'basic', mfa: false },
        encryption: { dataInTransit: false, dataAtRest: true },
        hasDefaultCredentials: true,
        openPorts: [22, 80, 443, 21]
      };
      
      const report = await vulnManager.scanDevice('test-device-001', deviceInfo);
      console.log(`✓ Vulnerability scan completed. Risk score: ${report.riskScore}`);
      
      // Test 3: Install patch
      if (report.vulnerabilities.length > 0) {
        console.log('\n3. Testing patch installation...');
        const patches = vulnManager.getPatchStatus('test-device-001');
        if (patches.length > 0) {
          await vulnManager.installPatch('test-device-001', patches[0].patchId);
          console.log('✓ Patch installation completed');
        }
      }
      
      // Test 4: Schedule automated scans
      console.log('\n4. Testing automated scan scheduling...');
      vulnManager.scheduleVulnerabilityScan('test-device-001', 1); // Every 1 hour for testing
      console.log('✓ Automated scan scheduled');
      
    } catch (error) {
      console.error('Vulnerability Management test failed:', error);
    }
  }
}
